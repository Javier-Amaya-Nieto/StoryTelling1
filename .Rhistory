relationship = "many-to-one"
)
View(base_final)
sum(is.na(base_final))
sum(is.na(base_final$poblacion))
sum(is.na(base_final$area))
sum(is.na(base_final$mpio_narea))
colSums(is.na(base_final))
# identificando los registros sin correspondencia
colSums(is.na(base_final))
# Dirección 1:
# Encuentra los municipios en la base de población que no están en la de área
poblacion_sin_area <- base_pob %>%
distinct(DPMP, DPNOM, MPIO) %>%
anti_join(base_area, by = "DPMP")
# Dirección 1:
# Encuentra los municipios en la base de población que no están en la de área
poblacion_sin_area <- base_pob %>%
distinct(dpmp, dpnom, mpio) %>%
anti_join(base_area, by = "dpmp")
# --- Reporte 1 ---
print("--- Reporte: Municipios en 'base_pob' que no están en 'base_area' ---")
if (nrow(poblacion_sin_area) > 0) {
print(paste("Se encontraron", nrow(poblacion_sin_area), "municipios sin correspondencia:"))
print(poblacion_sin_area)
} else {
print("✅ Todos los municipios de 'base_pob' tienen correspondencia en 'base_area'.")
}
# Dirección 2: de base_area a base_pob
# Encuentra los municipios en la base de área que no están en la de población
# usando el nombre de la llave en minúsculas: dpmp
area_sin_poblacion <- base_area %>%
anti_join(base_pob, by = "dpmp")
# --- Reporte 2 ---
print("--- Reporte: Municipios en 'base_area' que no están en 'base_pob' ---")
if (nrow(area_sin_poblacion) > 0) {
print(paste("Se encontraron", nrow(area_sin_poblacion), "municipios sin correspondencia:"))
print(area_sin_poblacion)
} else {
print("✅ Todos los municipios de 'base_area' tienen correspondencia en 'base_pob'.")
}
# Dirección 1: de base_pob a base_area
poblacion_sin_area <- base_pob %>%
distinct(dpmp, dpnom, mpio) %>%
anti_join(base_area, by = "dpmp")
View(poblacion_limpia_area)
View(poblacion_sin_area)
# --- Análisis para base_pob ---
n_filas_pob <- nrow(base_pob)
n_llaves_pob <- n_distinct(base_pob$dpmp)
n_filas_pob
n_llaves_pob
# N para la base de área
n_filas_area <- nrow(base_area)
n_llaves_area <- n_distinct(base_area$dpmp)
# UNICIDAD DE LAS LLAVES
# Esto ya lo habíamos verificado, pero incluimos el paso por seguridas
duplicados_en_area <- base_area %>%
count(dpmp) %>%
filter(n > 1)
duplicados_en_area
#VERIFICACIÓN DURANTE EL PROCESO DE UNIÓN
tabla_integrada <- left_join(base_pob, base_area, by = "dpmp")
# --- Verificación del Conteo de Filas ---
print("--- Verificación Post-Unión ---")
if (nrow(tabla_integrada) == nrow(base_pob)) {
print("✅ Verificación Exitosa: El número de filas en la tabla unida es igual al de la tabla 'muchos' original.")
print(paste("Filas en 'base_pob':", nrow(base_pob)))
print(paste("Filas en 'tabla_integrada':", nrow(tabla_integrada)))
} else {
print("❌ ALERTA: El número de filas ha cambiado después de la unión. Revise la unicidad de la llave en 'base_area'.")
}
# CARDINALIDAD
# N para la base población
n_filas_pob <- nrow(base_pob)
n_llaves_pob <- n_distinct(base_pob$dpmp)
# N para la base de área
n_filas_area <- nrow(base_area)
n_llaves_area <- n_distinct(base_area$dpmp)
# UNICIDAD DE LAS LLAVES
# Esto ya lo habíamos verificado, pero incluimos el paso por seguridas
duplicados_en_area <- base_area %>%
count(dpmp) %>%
filter(n > 1)
#VERIFICACIÓN DURANTE EL PROCESO DE UNIÓN
tabla_integrada <- left_join(base_pob, base_area, by = "dpmp")
# Conteo de N de la tabla original y la tabla resultante de la unión.
print(paste("Filas en 'base_pob':", nrow(base_pob)))
print(paste("Filas en 'basefinal':", nrow(base_final)))
print(paste("Duplicados en 'base_pob':", duplicados_en_area))
print(paste("Duplicados en 'base_pob':", nrow(duplicados_en_area)))
# CARDINALIDAD
# N para la base población
print(paste("Número de filas en la 'base_pob':", nrow(base_pob)))
print(paste("Número de llaves únicas 'base_pob':", n_distinct(base_pob$dpmp)))
# N para la base de área
print(paste("Número de filas en la 'base_area':", nrow(base_area)))
print(paste("Número de llaves únicas 'base_area':", n_distinct(base_area$dpmp)))
# UNICIDAD DE LAS LLAVES EN LA BASE AREA
# Esto ya lo habíamos verificado, pero incluimos el paso por seguridas
duplicados_en_area <- base_area %>%
count(dpmp) %>%
filter(n > 1)
print(paste("Duplicados en 'base_pob':", nrow(duplicados_en_area)))
#VERIFICACIÓN DURANTE EL PROCESO DE UNIÓN
# Conteo de N de la tabla original y la tabla resultante de la unión.
print(paste("Filas en 'base_pob':", nrow(base_pob)))
print(paste("Filas en 'base_final':", nrow(base_final)))
# CARDINALIDAD
# N para la base población
print(paste("Número de filas en la 'base_pob':", nrow(base_pob)))
print(paste("Número de llaves únicas 'base_pob':", n_distinct(base_pob$dpmp)))
# N para la base de área
print(paste("Número de filas en la 'base_area':", nrow(base_area)))
print(paste("Número de llaves únicas 'base_area':", n_distinct(base_area$dpmp)))
# UNICIDAD DE LAS LLAVES EN LA BASE AREA
# Esto ya lo habíamos verificado, pero incluimos el paso por seguridas
duplicados_en_area <- base_area %>%
count(dpmp) %>%
filter(n > 1)
print(paste("Duplicados en 'base_pob':", nrow(duplicados_en_area)))
#VERIFICACIÓN DURANTE EL PROCESO DE UNIÓN
# Conteo de N de la tabla original y la tabla resultante de la unión.
print(paste("Filas en 'base_pob':", nrow(base_pob)))
print(paste("Filas en 'base_final':", nrow(base_final)))
names(base_final)
#Arreglo de base de datos
base_final <- base_final %>%
select(-dp.y) %>%
rename(dp = dp.x) %>%
select(llave, everything())
# Guardar en un nuevo archivo
write.csv(base_final, "base_para_revision.csv", row.names = FALSE)
colSums(is.na(base_final))
View(poblacion_sin_area)
# Retirando la observación correspondiente a Mapiripana
base_filtrada <- base_final %>% filter(!dpmp==94663)
#Arreglo de base de datos
base_final <- base_final %>%
select(-dp.y) %>%
rename(dp = dp.x) %>%
select(llave, everything())
# Unir many to one
base_final <- left_join(
base_pob, base_area,
by = "dpmp",
relationship = "many-to-one"
)
# identificando los registros sin correspondencia
colSums(is.na(base_final))
# Dirección 1: de base_pob a base_area
poblacion_sin_area <- base_pob %>%
distinct(dpmp, dpnom, mpio) %>%
anti_join(base_area, by = "dpmp")
# identificando el municipio de diferencia entre la base de población y de área
poblacion_limpia_pob <- base_pob %>%
distinct(DPMP)
# identificando los registros sin correspondencia
colSums(is.na(base_final))
# Dirección 1: de base_pob a base_area
poblacion_sin_area <- base_pob %>%
distinct(dpmp, dpnom, mpio) %>%
anti_join(base_area, by = "dpmp")
# identificando el municipio de diferencia entre la base de población y de área
poblacion_limpia_pob <- base_pob %>%
distinct(dpmp)
poblacion_limpia_area <- base_area %>%
distinct(dpmp)
poblacion_limpia_area <- poblacion_limpia_area %>% mutate(var1=1)
tabla_integrada <- left_join(poblacion_limpia_pob, poblacion_limpia_area, by = "dpmp")
tabla_integrada %>%
filter(is.na(var1))
# Dirección 2: de base_area a base_pob
# Encuentra los municipios en la base de área que no están en la de población
# usando el nombre de la llave en minúsculas: dpmp
area_sin_poblacion <- base_area %>%
anti_join(base_pob, by = "dpmp")
# CARDINALIDAD
# N para la base población
print(paste("Número de filas en la 'base_pob':", nrow(base_pob)))
print(paste("Número de llaves únicas 'base_pob':", n_distinct(base_pob$dpmp)))
# N para la base de área
print(paste("Número de filas en la 'base_area':", nrow(base_area)))
print(paste("Número de llaves únicas 'base_area':", n_distinct(base_area$dpmp)))
# UNICIDAD DE LAS LLAVES EN LA BASE AREA
# Esto ya lo habíamos verificado, pero incluimos el paso por seguridas
duplicados_en_area <- base_area %>%
count(dpmp) %>%
filter(n > 1)
print(paste("Duplicados en 'base_pob':", nrow(duplicados_en_area)))
#VERIFICACIÓN DURANTE EL PROCESO DE UNIÓN
# Conteo de N de la tabla original y la tabla resultante de la unión.
print(paste("Filas en 'base_pob':", nrow(base_pob)))
print(paste("Filas en 'base_final':", nrow(base_final)))
#Arreglo de base de datos
base_final <- base_final %>%
select(-dp.y) %>%
rename(dp = dp.x) %>%
select(llave, everything())
# Retirando la observación correspondiente a Mapiripana
base_filtrada <- base_final %>% filter(!dpmp==94663)
# Haciendo la imputación de la población
base_final_imp <- base_filtrada %>%
# Paso 1: Crear una nueva variable para el grupo de área (usando quintiles)
mutate(area_quintil = ntile(mpio_narea, 5)) %>%
# Pasos 2 y 3: Agrupar por área y año, y luego imputar
group_by(area_quintil, ano) %>%
mutate(poblacion_imputada = if_else(
is.na(poblacion),
as.double(median(poblacion, na.rm = TRUE)),
as.double(poblacion)
)) %>%
ungroup()
colSums(is.na(base_final_imp))
View(base_final_imp)
base_final_imp <- base_final_imp %>%
mutate(densidad_pob = poblacion/mpio_narea)
# Creamos un objeto intermedio
datos_filtrados <- base_final_imp %>%
select(dpmp, ano, poblacion_imputada) %>%
filter(ano %in% c(1985, 2018))
# Creamos un segundo objeto intermedio 'datos_anchos'
datos_anchos <- datos_filtrados %>%
pivot_wider(
names_from = ano,
values_from = poblacion_imputada,
names_prefix = "pob_"
)
View(datos_anchos)
# Creamos el df con los crecimientos absolutos y relativos
crecimiento_municipios <- datos_anchos %>%
mutate(
# Crecimiento Absoluto
crecimiento_abs = pob_2018 - pob_1985,
# Crecimiento Porcentual
crecimiento_pct = crecimiento_abs / pob_1985) * 100
View(crecimiento_municipios)
# Ahora pegamos las nuevas dos variables a la base de análisis
# Seleccionando las variables
variables_crecimiento <- crecimiento_municipios %>%
select(dpmp, crecimiento_abs, crecimiento_pct)
# Unimos las nuevas variables a la base de datos principal
base_completa <- left_join(base_final_imp, variables_crecimiento, by = "dpmp")
View(base_completa)
View(variables_crecimiento)
View(base_final_imp)
# Unimos las nuevas variables a la base de datos principal
base_completa <- left_join(base_final_imp, variables_crecimiento, by = "dpmp")
# Creamos un objeto intermedio
datos_filtrados <- base_final_imp %>%
select(dpmp, ano, poblacion_imputada) %>%
filter(ano %in% c(1985, 2018))
# Creamos un segundo objeto intermedio 'datos_anchos'
datos_anchos <- datos_filtrados %>%
pivot_wider(
names_from = ano,
values_from = poblacion_imputada,
names_prefix = "pob_"
)
# Creamos el df con los crecimientos absolutos y relativos
crecimiento_municipios <- datos_anchos %>%
mutate(
# Crecimiento Absoluto
crecimiento_abs = pob_2018 - pob_1985,
# Crecimiento Porcentual
crecimiento_pct = crecimiento_abs / pob_1985) * 100)
# Creamos un objeto intermedio
datos_filtrados <- base_final_imp %>%
select(dpmp, ano, poblacion_imputada) %>%
filter(ano %in% c(1985, 2018))
# Creamos un segundo objeto intermedio 'datos_anchos'
datos_anchos <- datos_filtrados %>%
pivot_wider(
names_from = ano,
values_from = poblacion_imputada,
names_prefix = "pob_"
)
# Creamos el df con los crecimientos absolutos y relativos
crecimiento_municipios <- datos_anchos %>%
mutate(
# Crecimiento Absoluto
crecimiento_abs = pob_2018 - pob_1985,
# Crecimiento Porcentual
crecimiento_pct = (crecimiento_abs / pob_1985) * 100)
# Ahora pegamos las nuevas dos variables a la base de análisis
# Seleccionando las variables
variables_crecimiento <- crecimiento_municipios %>%
select(dpmp, crecimiento_abs, crecimiento_pct)
# Unimos las nuevas variables a la base de datos principal
base_completa <- left_join(base_final_imp, variables_crecimiento, by = "dpmp")
# Calculamos el área total de cada departamento
areas_departamentales <- base_completa %>%
distinct(dp, dpnom, dpmp, mpio_narea) %>%
group_by(dp, dpnom) %>%
summarise(area_total_depto = sum(mpio_narea)) %>%
ungroup()
View(areas_departamentales)
# Calculamos la población total por departamento y por año
poblacion_departamental <- base_completa %>%
group_by(dp, dpnom, ano) %>%
summarise(poblacion_total_depto = sum(poblacion_imputada)) %>%
ungroup()
View(poblacion_departamental)
# Paso 3: Unir población y área, y calcular la densidad departamental por año
densidad_departamental <- left_join(poblacion_departamental, areas_departamentales, by = c("dp", "dpnom")) %>%
mutate(densidad_depto = poblacion_total_depto / area_total_depto)
View(densidad_departamental)
View(densidad_departamental)
View(crecimiento_municipios)
# Añadimos el código de departamento a la tabla de crecimiento.
codigos_depto <- base_completa %>%
distinct(dpmp, dp, dpnom)
View(codigos_depto)
# Unimos los códigos de depto a la tabla de crecimiento municipal
crecimiento_municipios_con_depto <- left_join(crecimiento_municipios, codigos_depto, by = "dpmp")
View(crecimiento_municipios_con_depto)
# Agrupamos por departamento y sumamos el crecimiento absoluto
crecimiento_abs_depto <- crecimiento_municipios_con_depto %>%
group_by(dp, dpnom) %>%
summarise(crecimiento_abs_depto = sum(crecimiento_abs, na.rm = TRUE)) %>%
ungroup()
View(crecimiento_abs_depto)
View(poblacion_departamental)
# Creamos un nuevo objeto solo con los datos de los años extremos.
poblacion_filtrada_depto <- poblacion_departamental %>%
filter(ano %in% c(1985, 2018))
# Creamos un segundo objeto intermedio en formato ancho.
poblacion_ancha_depto <- poblacion_filtrada_depto %>%
pivot_wider(
names_from = ano,
values_from = poblacion_total_depto,
names_prefix = "pob_depto_"
)
View(poblacion_ancha_depto)
# Creamos el objeto final que contiene el cálculo.
poblacion_depto_extremos <- poblacion_ancha_depto %>%
mutate(
crecimiento_pct_depto = ((pob_depto_2018 - pob_depto_1985) / pob_depto_1985) * 100
)
# Uniendo las variables de crecimiento en un DF
crecimiento_departamental <- left_join(crecimiento_abs_depto, crecimiento_pct_depto, by = c("dp", "dpnom"))
# Creamos el objeto final que contiene el cálculo.
poblacion_depto_extremos <- poblacion_ancha_depto %>%
mutate(
crecimiento_pct_depto = ((pob_depto_2018 - pob_depto_1985) / pob_depto_1985) * 100
)
# Uniendo las variables de crecimiento en un DF
crecimiento_departamental <- left_join(crecimiento_abs_depto, crecimiento_pct_depto, by = c("dp", "dpnom"))
View(poblacion_depto_extremos)
# Uniendo las variables de crecimiento en un DF
crecimiento_departamental <- left_join(crecimiento_abs_depto, poblacion_depto_extremos, by = c("dp", "dpnom"))
View(crecimiento_departamental)
variables_pct_depto <- poblacion_depto_extremos %>%
select(dp, dpnom, crecimiento_pct_depto)
# Uniendo las variables de crecimiento en un DF
crecimiento_departamental <- left_join(crecimiento_abs_depto, variables_pct_depto, by = c("dp", "dpnom"))
View(densidad_departamental)
# Seleccionamos solo las llaves y la nueva variable de densidad
variables_densidad_depto <- densidad_departamental %>%
select(dp, dpnom, ano, densidad_depto)
# Unimos estas variables a la base principal
base_con_densidad <- left_join(base_final_imp, variables_densidad_depto, by = c("dp", "dpnom", "ano"))
# Unimos las variables de crecimiento al resultado del paso anterior
base_final_con_agregados <- left_join(base_con_densidad, crecimiento_departamental, by = c("dp", "dpnom"))
colSums(is.na(base_final_con_agregados))
# Unir many to one
base_final <- left_join(
base_pob, base_area,
by = "dpmp",
relationship = "many-to-one"
)
# identificando los registros sin correspondencia
colSums(is.na(base_final))
# Dirección 1: de base_pob a base_area
poblacion_sin_area <- base_pob %>%
distinct(dpmp, dpnom, mpio) %>%
anti_join(base_area, by = "dpmp")
# identificando el municipio de diferencia entre la base de población y de área
poblacion_limpia_pob <- base_pob %>%
distinct(dpmp)
poblacion_limpia_area <- base_area %>%
distinct(dpmp)
poblacion_limpia_area <- poblacion_limpia_area %>% mutate(var1=1)
tabla_integrada <- left_join(poblacion_limpia_pob, poblacion_limpia_area, by = "dpmp")
tabla_integrada %>%
filter(is.na(var1))
# Dirección 2: de base_area a base_pob
# Encuentra los municipios en la base de área que no están en la de población
# usando el nombre de la llave en minúsculas: dpmp
area_sin_poblacion <- base_area %>%
anti_join(base_pob, by = "dpmp")
# CARDINALIDAD
# N para la base población
print(paste("Número de filas en la 'base_pob':", nrow(base_pob)))
print(paste("Número de llaves únicas 'base_pob':", n_distinct(base_pob$dpmp)))
# N para la base de área
print(paste("Número de filas en la 'base_area':", nrow(base_area)))
print(paste("Número de llaves únicas 'base_area':", n_distinct(base_area$dpmp)))
# UNICIDAD DE LAS LLAVES EN LA BASE AREA
# Esto ya lo habíamos verificado, pero incluimos el paso por seguridas
duplicados_en_area <- base_area %>%
count(dpmp) %>%
filter(n > 1)
print(paste("Duplicados en 'base_pob':", nrow(duplicados_en_area)))
#VERIFICACIÓN DURANTE EL PROCESO DE UNIÓN
# Conteo de N de la tabla original y la tabla resultante de la unión.
print(paste("Filas en 'base_pob':", nrow(base_pob)))
print(paste("Filas en 'base_final':", nrow(base_final)))
#Arreglo de base de datos
base_final <- base_final %>%
select(-dp.y) %>%
rename(dp = dp.x) %>%
select(llave, everything())
# Retirando la observación correspondiente a Mapiripana
base_filtrada <- base_final %>% filter(!dpmp==94663)
# Haciendo la imputación de la población
base_final_imp <- base_filtrada %>%
# Paso 1: Crear una nueva variable para el grupo de área (usando quintiles)
mutate(area_quintil = ntile(mpio_narea, 5)) %>%
# Pasos 2 y 3: Agrupar por área y año, y luego imputar
group_by(area_quintil, ano) %>%
mutate(poblacion_imputada = if_else(
is.na(poblacion),
as.double(median(poblacion, na.rm = TRUE)),
as.double(poblacion)
)) %>%
ungroup()
base_final_imp <- base_final_imp %>%
mutate(densidad_pob = poblacion_imputada/mpio_narea)
# Creamos un objeto intermedio
datos_filtrados <- base_final_imp %>%
select(dpmp, ano, poblacion_imputada) %>%
filter(ano %in% c(1985, 2018))
# Creamos un segundo objeto intermedio 'datos_anchos'
datos_anchos <- datos_filtrados %>%
pivot_wider(
names_from = ano,
values_from = poblacion_imputada,
names_prefix = "pob_"
)
# Creamos el df con los crecimientos absolutos y relativos
crecimiento_municipios <- datos_anchos %>%
mutate(
# Crecimiento Absoluto
crecimiento_abs = pob_2018 - pob_1985,
# Crecimiento Porcentual
crecimiento_pct = (crecimiento_abs / pob_1985) * 100)
# Ahora pegamos las nuevas dos variables a la base de análisis
# Seleccionando las variables
variables_crecimiento <- crecimiento_municipios %>%
select(dpmp, crecimiento_abs, crecimiento_pct)
# Unimos las nuevas variables a la base de datos principal
base_completa <- left_join(base_final_imp, variables_crecimiento, by = "dpmp")
# DENSIDAD POBLACIONAL
# Calculamos el área total de cada departamento
areas_departamentales <- base_completa %>%
distinct(dp, dpnom, dpmp, mpio_narea) %>%
group_by(dp, dpnom) %>%
summarise(area_total_depto = sum(mpio_narea)) %>%
ungroup()
# Calculamos la población total por departamento y por año
poblacion_departamental <- base_completa %>%
group_by(dp, dpnom, ano) %>%
summarise(poblacion_total_depto = sum(poblacion_imputada)) %>%
ungroup()
# Ahora unimos la población y área para calcular la densidad poblacional departamental por año
densidad_departamental <- left_join(poblacion_departamental, areas_departamentales, by = c("dp", "dpnom")) %>%
mutate(densidad_depto = poblacion_total_depto / area_total_depto)
# CRECIMIENTO POBLACIONAL (ABSOLUTO Y PORCENTUAL)
# Crecimiento Absoluto Departamental
## Añadimos el código de departamento a la tabla de crecimiento.
codigos_depto <- base_completa %>%
distinct(dpmp, dp, dpnom)
## Unimos los códigos de depto a la tabla de crecimiento municipal
crecimiento_municipios_con_depto <- left_join(crecimiento_municipios, codigos_depto, by = "dpmp")
## Agrupamos por departamento y sumamos el crecimiento absoluto
crecimiento_abs_depto <- crecimiento_municipios_con_depto %>%
group_by(dp, dpnom) %>%
summarise(crecimiento_abs_depto = sum(crecimiento_abs, na.rm = TRUE)) %>%
ungroup()
# Crecimiento Porcentual Departamental
# Creamos un nuevo objeto solo con los datos de los años extremos.
poblacion_filtrada_depto <- poblacion_departamental %>%
filter(ano %in% c(1985, 2018))
# Creamos un segundo objeto intermedio en formato ancho.
poblacion_ancha_depto <- poblacion_filtrada_depto %>%
pivot_wider(
names_from = ano,
values_from = poblacion_total_depto,
names_prefix = "pob_depto_"
)
# Creamos el objeto final que contiene el cálculo.
poblacion_depto_extremos <- poblacion_ancha_depto %>%
mutate(
crecimiento_pct_depto = ((pob_depto_2018 - pob_depto_1985) / pob_depto_1985) * 100
)
variables_pct_depto <- poblacion_depto_extremos %>%
select(dp, dpnom, crecimiento_pct_depto)
# Uniendo las variables de crecimiento en un DF
crecimiento_departamental <- left_join(crecimiento_abs_depto, variables_pct_depto, by = c("dp", "dpnom"))
# UNIENDO LAS NUEVAS VARIABLES CREADS
# Seleccionamos solo las llaves y la nueva variable de densidad
variables_densidad_depto <- densidad_departamental %>%
select(dp, dpnom, ano, densidad_depto)
# Unimos estas variables a la base principal
base_con_densidad <- left_join(base_final_imp, variables_densidad_depto, by = c("dp", "dpnom", "ano"))
# Unimos las variables de crecimiento al resultado del paso anterior
base_final_con_agregados <- left_join(base_con_densidad, crecimiento_departamental, by = c("dp", "dpnom"))
colSums(is.na(base_final_con_agregados))
# renombrando la base de análisis
df_clean <- base_final_con_agregados
View(df_clean)
