---
title: 'Taller 1:  Introducción al uso de datos'
author: "Camila Caraballo, Laura Rivera y Javier Amaya"
date: "2025-08-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Exploración y visualización de datos para lo socioeconómico: Clase 1

## Facultad de Economía, Universidad de los Andes

```{r}
# Cargar paquetes
#install.packages("openxlsx")
library(openxlsx)
#install.packages("dplyr")
library(dplyr)
library(tibble)
library(stringr)
library(stringi)
library(janitor)
library(tidyr)

```

### Entendimiento de los datos

#### 1. Idenfique y jusfique la unidad de observación en cada tabla de datos suministrados

**Tabla de área:** la unidad de observación es el *municipio*, ya que constituye el elemento básico sobre el cual se registran los datos. Cada fila tiene información del área y año de creación del municipio.

**Tabla de población:** la unidad de observación también es una combinación entre *municipio y año*. De esta manera, cada fila contiene esencialmente información de la población de cada municipio para cada uno de los 4 censos(1985, 1993, 2005 y 2018).

```{r}
# Cargar las bases de datos
base_area <- read.csv("mun_area.csv")
base_pob <- read.xlsx("pob_censal.xlsx")

```

#### 2. Clasifique cada variable como idenficación o medición; indique tipo y formato.

```{r}
# Observar estructura de base area
str(base_area)

# Observar estructura de base población
str(base_pob)

# Número total de filas
nrow(base_pob)

#Creación de un diccionario 

Diccionario <- tribble(
  ~Variable,~Clasificación,~Tipo,~Formato,
   "DP","Identificación","Nominal","Numérico",
   "DPMP", "Identificación","Nominal", "Numérico",
   "MPIO_NAREA", "Medición", "Continuo", "Numérico",
   "AÑO_CREACION", "Medición", "Ordinal", "Numérico", 
   "DPNOM", "Identiticación", "Nominal", "Texto",
   "MPIO", "Identificación", "Nominal", "Texto",
   "AÑO", "Identificación", "Ordinal", "Numérico", 
  "POBLACIÓN", "Medición", "Continuo", "Numérico", 
)

print(Diccionario)
```

#### 3. Proponga al menos 3 reglas mínimas de consistencia para asegurar la calidad de los datos de las variables disponibles y que constituyen parte de la documentación del ejercicio. (e.g., AÑO ∈ {1985,1993,2005,2018}).

```{r}
Reglas <- tribble(
  ~Variable,~Tipo_de_regla,~Regla,
   "AÑO","Dominio","AÑO ∈{1985, 1993, 2005, 2018}",
   "POBLACIÓN", "Rango","Población > 0",
   "ÁREA", "Rango", "Área > 0 "
)

print(Reglas)
```


### Preparación de los datos

#### 1. Construya la llave única para la tabla de población (sugerencia: DPMP + AÑO).

```{r}
# Llave en población 
base_pob <- base_pob %>%
  mutate(llave = paste(DPMP, AÑO, sep = "_"))
```

#### 2. Verifique duplicados; reporte conteos y la decisión de tratamiento
Verificamos los duplicados y algunas reglas adicionales relacionadas con los N totales: 
a- La cantidad de valores distintos de municipios en la variable DPMP debe ser igual en ambas bases. 
b- La cantidad de filas en la base de datos de censos poblacionales debe ser 4 veces la cantidad de municipios en la base. 

```{r}
# Verificar duplicados
print(paste("Duplicados en base poblaciones:", anyDuplicated(base_pob$llave))) 
print(paste("Duplicados en base áreas:", anyDuplicated(base_area$DPMP))) 


# CONTEOS
# Número de observavciones en cada base
n_observaciones_pob <- nrow(base_pob)
n_observaciones_area <- nrow(base_area)
# Contar municipios únicos en cada dataframe
n_municipios_pob <- n_distinct(base_pob$DPMP)
n_municipios_area <- n_distinct(base_area$DPMP)

# Imprimir los resultados
print(paste("Número de observaciones en la base de población:", n_observaciones_pob))
print(paste("Número de observaciones en la base de áreas:", n_observaciones_area))
print(paste("Número de municipios únicos en la base de población:", n_municipios_pob))
print(paste("Número de municipios únicos en la base de áreas:", n_municipios_area))

```
Con esta información podemos concluir que no hay duplicados en las bases iniciales, pero hay diferencia en el número de municipios de las bases(1121 municipios en la base de áreas y 1122 en la base de datos censales). 

#### 3. Explique qué tipo de unión tendrían las tablas disponibles y por qué.

Se propone realizar un left join con relación many-to-one partiendo de la tabla de poblaciones, dado que la tabla de población contiene múltiples observaciones por municipio a lo largo de distintos años, mientras que la tabla de área registra una única observación por municipio (información estática). Con este tipo de unión se busca conservar todas las filas de la tabla de población y añadir a cada una de ellas los atributos de área correspondientes al municipio. De esta manera, se pretende evitar la pérdida de información temporal de población y, al mismo tiempo, complementar cada registro municipio–año con la información de área cuando esté disponible.

#### 4. Asegure tipos de datos correctos de acuerdo con las reglas que idenficó previamente (e.g. DP, DPMP caracteres que pueden iniciar con “0”; Población entera).

```{r}

# --- REGLA 1: Dominio de la variable AÑO ---
# Regla: La variable AÑO solo debe contener los valores {1985, 1993, 2005, 2018}.
table(base_pob$AÑO)

# --- REGLA 2: Rango de la variable POBLACIÓN ---
poblacion_invalida <- base_pob %>%
  filter(Población <= 0)
#reemplazando los ceros por NA 
base_pob <- base_pob %>%
  mutate(Población = if_else(Población <= 0, NA_integer_, Población))

# --- REGLA 3: Rango de la variable ÁREA ---
# Regla: El valor de Área debe ser mayor que 0.
area_invalida <- base_area %>%
  filter(MPIO_NAREA <= 0)

```

#### 5. Detecte datos faltantes y decida su tratamiento, si es necesario en el contexto de este ejercicio.

```{r}

# Calcular NA 
colSums(is.na(base_pob))
colSums(is.na(base_area))

```
Se entiende que la variable año_creación hace referencia al momento en que un municipio fue oficialmente constituido. Los vacíos en los datos de población parecen estar asociados a que algunos años de observación son previos a la fecha de creación de los municipios; es decir, probablemente no existe información disponible antes de que fueran reconocidos como entidades administrativas. Para solucionar esta limitación se propone imputar los valores faltantes utilizando como referencia la mediana de la población en municipios con un área similar para el año correspondiente. En este paso se identifican 155 datos faltantes en la base de población en la variable "Población". 

#### 6. Estandarice nombres (mayúsculas/acentos) en DPNOM y MPIO, si es necesario.

```{r}
# Limpiando los nombres
base_area <- clean_names(base_area)
base_pob <- clean_names(base_pob)

```

#### 7. A partir de la estructura larga de la tabla población (AÑO en columna), cree una versión ancha con columnas Pob_1985, Pob_1993, Pob_2005, Pob_2018 y guárdela en un nuevo archivo.

```{r}
# Crear la versión ancha
base_ancha_pob <- base_pob %>%
  select(dp, dpnom, dpmp, mpio, ano, poblacion) %>%
  spread(key = ano, value = poblacion)%>%
  rename(
    Pob_1985 = `1985`,
    Pob_1993 = `1993`,
    Pob_2005 = `2005`,
    Pob_2018 = `2018`
  )

# Guardar en un nuevo archivo
write.csv(base_ancha_pob, "base_ancha.csv", row.names = FALSE)

```

#### 8. Explique cuándo trabajar en largo vs. en ancho para las operaciones siguientes.

La elección entre el formato largo y ancho depende de la operación: el formato largo es ideal para analizar y visualizar tendencias a lo largo del tiempo como en la mayoría de análisis requeridos en este trabajo, mientras que el formato ancho es necesario para calcular cambios entre puntos temporales específicos, como el crecimiento poblacional. Por lo tanto, se decide mantener la tabla de datos principal en formato largo y crear una versión ancha temporal con pivot_wider() con el proposito de  responder a la pregunta de cuáles son los 20 municipios de Colombia con mayor crecimiento poblacional desde 1985.


### Integración de tablas (join), validaciones y cálculos

#### 1. Realice la unión de las tablas población (largo) con mun_area.csv

```{r}
# Unir many to one 
base_final <- left_join(
  base_pob, base_area,
  by = "dpmp",
  relationship = "many-to-one"   
)

```

#### 2. Reporte registros sin correspondencia en ambas direcciones.

```{r}
# identificando los registros sin correspondencia
colSums(is.na(base_final))


# Dirección 1: de base_pob a base_area
poblacion_sin_area <- base_pob %>%
  distinct(dpmp, dpnom, mpio) %>% 
  anti_join(base_area, by = "dpmp")
# identificando el municipio de diferencia entre la base de población y de área
poblacion_limpia_pob <- base_pob %>%
  distinct(dpmp)
poblacion_limpia_area <- base_area %>%
  distinct(dpmp)
poblacion_limpia_area <- poblacion_limpia_area %>% mutate(var1=1) 
tabla_integrada <- left_join(poblacion_limpia_pob, poblacion_limpia_area, by = "dpmp")
tabla_integrada %>%
  filter(is.na(var1))

# Dirección 2: de base_area a base_pob
# Encuentra los municipios en la base de área que no están en la de población
# usando el nombre de la llave en minúsculas: dpmp
area_sin_poblacion <- base_area %>%
  anti_join(base_pob, by = "dpmp")

```

al revisar estos resultados observamos que el municipio con DPMP 94663 (mapiripana) solo está en la base de datos censales de los municipios. Considerando que no tenemos información que nos permita imputar estos datos y su irrelevancia para responder a las preguntas de indagación, se decide retirar este municipio.  

#### 3. Documente la cardinalidad (muchos-a-uno) y cómo evita relaciones muchos-a-muchos.

Teniendo como referencia la estrategia planteada en el punto 3 de la preparación de datos, verificamos el N de observaciones y el número de llaves distintas en cada base para identificar la tabla de "muchos" y la tabla de "uno". Además de esto se debe garantizar que las llaves no tengan duplicados (paso realizado previamente también) al igual que se debe hacer una verificación de los N totales durante el proceso de unión.   

```{r}

# CARDINALIDAD
# N para la base población
print(paste("Número de filas en la 'base_pob':", nrow(base_pob)))
print(paste("Número de llaves únicas 'base_pob':", n_distinct(base_pob$dpmp)))

# N para la base de área
print(paste("Número de filas en la 'base_area':", nrow(base_area)))
print(paste("Número de llaves únicas 'base_area':", n_distinct(base_area$dpmp)))

# UNICIDAD DE LAS LLAVES EN LA BASE AREA
# Esto ya lo habíamos verificado, pero incluimos el paso por seguridas
duplicados_en_area <- base_area %>%
  count(dpmp) %>%
  filter(n > 1)

print(paste("Duplicados en 'base_pob':", nrow(duplicados_en_area)))

#VERIFICACIÓN DURANTE EL PROCESO DE UNIÓN
# Conteo de N de la tabla original y la tabla resultante de la unión. 
print(paste("Filas en 'base_pob':", nrow(base_pob)))
print(paste("Filas en 'base_final':", nrow(base_final)))

```
```{r}
#Arreglo de base de datos 
base_final <- base_final %>%
  select(-dp.y) %>%
  rename(dp = dp.x) %>%
  select(llave, everything())

# Retirando la observación correspondiente a Mapiripana
base_filtrada <- base_final %>% filter(!dpmp==94663)

# Haciendo la imputación de la población 
base_final_imp <- base_filtrada %>%
  # Paso 1: Crear una nueva variable para el grupo de área (usando quintiles)
  mutate(area_quintil = ntile(mpio_narea, 5)) %>%
  # Pasos 2 y 3: Agrupar por área y año, y luego imputar
  group_by(area_quintil, ano) %>%
  mutate(poblacion_imputada = if_else(
    is.na(poblacion),
    as.double(median(poblacion, na.rm = TRUE)), 
    as.double(poblacion)
  )) %>%
  ungroup()

```



### Cálculos de interés (medición) Con la tabla integrada:

#### 1. Densidad poblacional = Población / MPIO_NAREA.

```{r}
base_final_imp <- base_final_imp %>% 
  mutate(densidad_pob = poblacion_imputada/mpio_narea)
```


#### 2. Crecimiento absoluto 1985→2018 y crecimiento porcentual 1985→2018 por municipio.

Teniendo en cuenta la propuesta realizada de manejo de esta variable usando datos en formato ancho: 

```{r}

# Creamos un objeto intermedio
datos_filtrados <- base_final_imp %>%
  select(dpmp, ano, poblacion_imputada) %>%
  filter(ano %in% c(1985, 2018))
# Creamos un segundo objeto intermedio 'datos_anchos'
datos_anchos <- datos_filtrados %>%
  pivot_wider(
    names_from = ano,
    values_from = poblacion_imputada,
    names_prefix = "pob_"
  )
# Creamos el df con los crecimientos absolutos y relativos
crecimiento_municipios <- datos_anchos %>%
  mutate(
    # Crecimiento Absoluto
    crecimiento_abs = pob_2018 - pob_1985,
    
    # Crecimiento Porcentual
    crecimiento_pct = (crecimiento_abs / pob_1985) * 100)

# Ahora pegamos las nuevas dos variables a la base de análisis
# Seleccionando las variables
variables_crecimiento <- crecimiento_municipios %>%
  select(dpmp, crecimiento_abs, crecimiento_pct)

# Unimos las nuevas variables a la base de datos principal
base_completa <- left_join(base_final_imp, variables_crecimiento, by = "dpmp")

```

#### 3. Agregación por departamento (DP) para densidad y crecimiento (aclare la definición usada).

Para estas variables se usará una aproximación de suma del área total de cada municipio (constante en el tiempo) y suma de la población total por municipio para cada año (progresa durante los diferentes censos). Luego de esto sí calculan la densidad y crecimiento poblacional. 

```{r}
# DENSIDAD POBLACIONAL

# Calculamos el área total de cada departamento
areas_departamentales <- base_completa %>%
  distinct(dp, dpnom, dpmp, mpio_narea) %>% 
  group_by(dp, dpnom) %>%
  summarise(area_total_depto = sum(mpio_narea)) %>%
  ungroup()

# Calculamos la población total por departamento y por año
poblacion_departamental <- base_completa %>%
  group_by(dp, dpnom, ano) %>%
  summarise(poblacion_total_depto = sum(poblacion_imputada)) %>%
  ungroup()

# Ahora unimos la población y área para calcular la densidad poblacional departamental por año
densidad_departamental <- left_join(poblacion_departamental, areas_departamentales, by = c("dp", "dpnom")) %>%
  mutate(densidad_depto = poblacion_total_depto / area_total_depto)


# CRECIMIENTO POBLACIONAL (ABSOLUTO Y PORCENTUAL)

# Crecimiento Absoluto Departamental 

  ## Añadimos el código de departamento a la tabla de crecimiento.
  codigos_depto <- base_completa %>% 
    distinct(dpmp, dp, dpnom)
  
  ## Unimos los códigos de depto a la tabla de crecimiento municipal
  crecimiento_municipios_con_depto <- left_join(crecimiento_municipios, codigos_depto, by = "dpmp")
  
  ## Agrupamos por departamento y sumamos el crecimiento absoluto
  crecimiento_abs_depto <- crecimiento_municipios_con_depto %>%
    group_by(dp, dpnom) %>%
    summarise(crecimiento_abs_depto = sum(crecimiento_abs, na.rm = TRUE)) %>%
    ungroup()


# Crecimiento Porcentual Departamental 

# Creamos un nuevo objeto solo con los datos de los años extremos.
poblacion_filtrada_depto <- poblacion_departamental %>%
  filter(ano %in% c(1985, 2018))
# Creamos un segundo objeto intermedio en formato ancho.
poblacion_ancha_depto <- poblacion_filtrada_depto %>%
  pivot_wider(
    names_from = ano,
    values_from = poblacion_total_depto,
    names_prefix = "pob_depto_"
  )
# Creamos el objeto final que contiene el cálculo.
poblacion_depto_extremos <- poblacion_ancha_depto %>%
  mutate(
    crecimiento_pct_depto = ((pob_depto_2018 - pob_depto_1985) / pob_depto_1985) * 100
  )
variables_pct_depto <- poblacion_depto_extremos %>%
  select(dp, dpnom, crecimiento_pct_depto)

# Uniendo las variables de crecimiento en un DF
crecimiento_departamental <- left_join(crecimiento_abs_depto, variables_pct_depto, by = c("dp", "dpnom"))

# UNIENDO LAS NUEVAS VARIABLES CREADS

# Seleccionamos solo las llaves y la nueva variable de densidad
variables_densidad_depto <- densidad_departamental %>%
  select(dp, dpnom, ano, densidad_depto)

# Unimos estas variables a la base principal
base_con_densidad <- left_join(base_final_imp, variables_densidad_depto, by = c("dp", "dpnom", "ano"))

# Unimos las variables de crecimiento al resultado del paso anterior
base_final_con_agregados <- left_join(base_con_densidad, crecimiento_departamental, by = c("dp", "dpnom"))

# renombrando la base de análisis
df_clean <- base_final_con_agregados


```

### Preguntas de indagación

#### 1. ¿Cuáles son los 20 municipios de Colombia con mayor crecimiento poblacional desde 1985? Absoluto y porcentual.

#### 2. ¿Cuáles son los 10 municipios de Colombia con mayor densidad en 1993 y en 2018?

#### 3. ¿Cuáles son los 5 departamentos de Colombia con mayor densidad en 1993 y en 2018?

#### 4. ¿Cómo ha cambiado la distribución de la población municipal colombiana desde 1985? Puede realizar un análisis por cuar les o percen les con gráficos.

