---
title: 'Taller 1:  Introducción al uso de datos'
author: "Camila Caraballo, Laura Rivera y Javier Amaya"
date: "2025-08-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Exploración y visualización de datos para lo socioeconómico: Clase 1

## Facultad de Economía, Universidad de los Andes

```{r}
# Cargar paquetes
#install.packages("openxlsx")
library(openxlsx)
#install.packages("dplyr")
library(dplyr)
library(tibble)
library(stringr)
library(stringi)
library(janitor)
library(tidyr)

```

### Entendimiento de los datos

#### 1. Idenfique y jusfique la unidad de observación en cada tabla de datos suministrados

**Tabla de área:** la unidad de observación es el *municipio*, ya que constituye el elemento básico sobre el cual se registran los datos. Cada fila tiene información del área y año de creación del municipio.

**Tabla de población:** la unidad de observación también es una combinación entre *municipio y año*. De esta manera, cada fila contiene esencialmente información de la población de cada municipio para cada uno de los 4 censos(1985, 1993, 2005 y 2018).

```{r}
# Cargar las bases de datos
base_area <- read.csv("mun_area.csv")
base_pob <- read.xlsx("pob_censal.xlsx")

```

#### 2. Clasifique cada variable como idenficación o medición; indique tipo y formato.

```{r}
# Observar estructura de base area
str(base_area)

# Observar estructura de base población
str(base_pob)

# Número total de filas
nrow(base_pob)

#Creación de un diccionario 

Diccionario <- tribble(
  ~Variable,~Clasificación,~Tipo,~Formato,
   "DP","Identificación","Nominal","Numérico",
   "DPMP", "Identificación","Nominal", "Numérico",
   "MPIO_NAREA", "Medición", "Continuo", "Numérico",
   "AÑO_CREACION", "Medición", "Ordinal", "Numérico", 
   "DPNOM", "Identiticación", "Nominal", "Texto",
   "MPIO", "Identificación", "Nominal", "Texto",
   "AÑO", "Identificación", "Ordinal", "Numérico", 
  "POBLACIÓN", "Medición", "Continuo", "Numérico", 
)

print(Diccionario)
```

#### 3. Proponga al menos 3 reglas mínimas de consistencia para asegurar la calidad de los datos de las variables disponibles y que constituyen parte de la documentación del ejercicio. (e.g., AÑO ∈ {1985,1993,2005,2018}).

```{r}
Reglas <- tribble(
  ~Variable,~Tipo_de_regla,~Regla,
   "AÑO","Dominio","AÑO ∈{1985, 1993, 2005, 2018}",
   "POBLACIÓN", "Rango","Población > 0",
   "ÁREA", "Rango", "Área > 0 "
)

print(Reglas)
```


### Preparación de los datos

#### 1. Construya la llave única para la tabla de población (sugerencia: DPMP + AÑO).

```{r}
# Llave en población 
base_pob <- base_pob %>%
  mutate(llave = paste(DPMP, AÑO, sep = "_"))
```

#### 2. Verifique duplicados; reporte conteos y la decisión de tratamiento
Verificamos los duplicados y algunas reglas adicionales relacionadas con los N totales: 
a- La cantidad de valores distintos de municipios en la variable DPMP debe ser igual en ambas bases. 
b- La cantidad de filas en la base de datos de censos poblacionales debe ser 4 veces la cantidad de municipios en la base. 

```{r}
# Verificar duplicados
print(paste("Duplicados en base poblaciones:", anyDuplicated(base_pob$llave))) 
print(paste("Duplicados en base áreas:", anyDuplicated(base_area$DPMP))) 


# CONTEOS
# Número de observavciones en cada base
n_observaciones_pob <- nrow(base_pob)
n_observaciones_area <- nrow(base_area)
# Contar municipios únicos en cada dataframe
n_municipios_pob <- n_distinct(base_pob$DPMP)
n_municipios_area <- n_distinct(base_area$DPMP)

# Imprimir los resultados
print(paste("Número de observaciones en la base de población:", n_observaciones_pob))
print(paste("Número de observaciones en la base de áreas:", n_observaciones_area))
print(paste("Número de municipios únicos en la base de población:", n_municipios_pob))
print(paste("Número de municipios únicos en la base de áreas:", n_municipios_area))

```
Con esta información podemos concluir que no hay duplicados en las bases iniciales, pero hay diferencia en el número de municipios de las bases(1121 municipios en la base de áreas y 1122 en la base de datos censales). 

#### 3. Explique qué tipo de unión tendrían las tablas disponibles y por qué.

Se propone realizar un left join con relación many-to-one partiendo de la tabla de poblaciones, dado que la tabla de población contiene múltiples observaciones por municipio a lo largo de distintos años, mientras que la tabla de área registra una única observación por municipio (información estática). Con este tipo de unión se busca conservar todas las filas de la tabla de población y añadir a cada una de ellas los atributos de área correspondientes al municipio. De esta manera, se pretende evitar la pérdida de información temporal de población y, al mismo tiempo, complementar cada registro municipio–año con la información de área cuando esté disponible.

#### 4. Asegure tipos de datos correctos de acuerdo con las reglas que idenficó previamente (e.g. DP, DPMP caracteres que pueden iniciar con “0”; Población entera).

```{r}

# --- REGLA 1: Dominio de la variable AÑO ---
# Regla: La variable AÑO solo debe contener los valores {1985, 1993, 2005, 2018}.
table(base_pob$AÑO)

# --- REGLA 2: Rango de la variable POBLACIÓN ---
poblacion_invalida <- base_pob %>%
  filter(Población <= 0)
#reemplazando los ceros por NA 
base_pob <- base_pob %>%
  mutate(Población = if_else(Población <= 0, NA_integer_, Población))

# --- REGLA 3: Rango de la variable ÁREA ---
# Regla: El valor de Área debe ser mayor que 0.
area_invalida <- base_area %>%
  filter(MPIO_NAREA <= 0)

```

#### 5. Detecte datos faltantes y decida su tratamiento, si es necesario en el contexto de este ejercicio.

```{r}

# Calcular NA 
colSums(is.na(base_pob))
colSums(is.na(base_area))

```
Se entiende que la variable año_creación hace referencia al momento en que un municipio fue oficialmente constituido. Los vacíos en los datos de población parecen estar asociados a que algunos años de observación son previos a la fecha de creación de los municipios; es decir, probablemente no existe información disponible antes de que fueran reconocidos como entidades administrativas. Para solucionar esta limitación se propone imputar los valores faltantes utilizando como referencia la mediana de la población en municipios con un área similar.

#### 6. Estandarice nombres (mayúsculas/acentos) en DPNOM y MPIO, si es necesario.

```{r}
# Limpiando los nombres
base_area <- clean_names(base_area)
base_pob <- clean_names(base_pob)

```

#### 7. A partir de la estructura larga de la tabla población (AÑO en columna), cree una versión ancha con columnas Pob_1985, Pob_1993, Pob_2005, Pob_2018 y guárdela en un nuevo archivo.

```{r}
# Crear la versión ancha
base_ancha_pob <- base_pob %>%
  select(dp, dpnom, dpmp, mpio, ano, poblacion) %>%
  spread(key = ano, value = poblacion)%>%
  rename(
    Pob_1985 = `1985`,
    Pob_1993 = `1993`,
    Pob_2005 = `2005`,
    Pob_2018 = `2018`
  )

# Guardar en un nuevo archivo
write.csv(base_ancha_pob, "base_ancha.csv", row.names = FALSE)

```

#### 8. Explique cuándo trabajar en largo vs. en ancho para las operaciones siguientes.

El formato largo de una base es cuando se tienen observaciones repetidas de una misma variable, como en nuestro caso en la tabla de **base_final**, que cuenta con 8 variables y 44.484 observaciones y es preferible trabajar con esta base para realizar operaciones dado que la llave que se construyó con DMPM y Año, permite que al unicarla con la base de **area** que esta en formato ancho, se conserve la relación de muchos registros de población contra un único registro de área por municipio y año. Mientras que, en el formato ancho se concentran atributos (como población y tiempo) en varias columnas, de manera que la tabla llamada **base_ancha** contiene 9 variables y 11.121 observaciones y esta nos puede ayudar a verificar duplicados o detectar valores faltantes (NA).

### Integración de tablas (join), validaciones y cálculos

#### 1. Realice la unión de las tablas población (largo) con mun_area.csv

```{r}
# Unir many to one 
base_final <- left_join(
  base_pob, base_area,
  by = "DPMP",
  relationship = "many-to-one"   
)

#Revisión de la unión
base_final <- base_final %>%
  arrange(DPMP, AÑO)

#Arreglo de base de datos 
base_final <- base_final %>%
  select(-DP.y) %>%
  rename(DP = DP.x) %>%
  select(llave, everything())
```

#### 2. Reporte registros sin correspondencia en ambas direcciones.

```{r}
# identificando el municipio diferente
poblacion_limpia_pob <- base_pob %>%
  distinct(DPMP)
poblacion_limpia_area <- base_area %>%
  distinct(DPMP)
poblacion_limpia_area <- poblacion_limpia_area %>% mutate(var1=1) 
tabla_integrada <- left_join(poblacion_limpia_pob, poblacion_limpia_area, by = "DPMP")
tabla_integrada %>%
  filter(is.na(var1))

# Validación B
# Agrupar por municipio y contar el número de registros (años) por municipio
conteo_censos_por_municipio <- base_pob %>%
  count(DPMP, name = "n_registros")
# revisando la cantidad de registros por municipio
table(conteo_censos_por_municipio$n_registros)
```

al revisar estos resultados observamos que el municipio con DPMP 94663 solo está en la base de datos censales de los municipios. Considerando que no tenemos información que nos permita imputar la información 

#### 3. Documente la cardinalidad (muchos-a-uno) y cómo evita relaciones muchos-a-muchos.

### Cálculos de interés (medición) Con la tabla integrada:

#### 1. Densidad poblacional = Población / MPIO_NAREA.

#### 2. Crecimiento absoluto 1985→2018 y crecimiento porcentual 1985→2018 por municipio.

#### 3. Agregación por departamento (DP) para densidad y crecimiento (aclare la definición usada).

### Preguntas de indagación

#### 1. ¿Cuáles son los 20 municipios de Colombia con mayor crecimiento poblacional desde 1985? Absoluto y porcentual.

#### 2. ¿Cuáles son los 10 municipios de Colombia con mayor densidad en 1993 y en 2018?

#### 3. ¿Cuáles son los 5 departamentos de Colombia con mayor densidad en 1993 y en 2018?

#### 4. ¿Cómo ha cambiado la distribución de la población municipal colombiana desde 1985? Puede realizar un análisis por cuar les o percen les con gráficos.

